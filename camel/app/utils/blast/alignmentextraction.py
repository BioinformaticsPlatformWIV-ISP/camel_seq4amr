import re

import logging
from pathlib import Path
from typing import Tuple, Dict


class AlignmentExtraction(object):
    """
    Class that extracts alignments from output files generated by Blast.
    The files have to be created with the '-outfmt 0' option.
    """

    MAX_QUERY_LENGTH = 65

    @staticmethod
    def get_alignments(alignment_file: Path) -> Dict[Tuple[str, str], str]:
        """
        Returns the individual alignments from the input file.
        :param alignment_file: file containing the alignments
        :return: Dictionary of alignments
        """
        logging.info(f'Parsing {alignment_file}')
        with open(alignment_file) as handle:
            full_text = handle.read()
            text_parts = re.split('^>', full_text, flags=re.MULTILINE)

        alignments = {}
        last_query = AlignmentExtraction.__get_query(text_parts[0])
        for text_part in text_parts:
            if AlignmentExtraction.__is_alignment(text_part):
                query = last_query
                subject = text_part.split('\n')[0].split(' ')[0]
                key = AlignmentExtraction.get_key(subject, query)
                if key in alignments:
                    raise ValueError(f"Duplicate key: {key}")
                alignments[key] = AlignmentExtraction.__clean_alignment(text_part)
            new_query = AlignmentExtraction.__get_query(text_part)
            if new_query is not None:
                last_query = new_query
        logging.info(f"{len(alignments)} alignments extracted from '{alignment_file.name}'")
        return alignments

    @staticmethod
    def get_key(subject: str, query: str) -> Tuple[str, str]:
        """
        Generates the key for the given query.
        :param subject: Subject
        :param query: Query
        :return: key
        """
        return subject, AlignmentExtraction.__cleanup_query_line(query)

    @staticmethod
    def __get_query(text_part: str) -> str:
        """
        Returns the last query from the given text part.
        :param text_part: Text part
        :return: Query
        """
        for line in reversed(text_part.split('\n')):
            if line.startswith('Query='):
                return AlignmentExtraction.__cleanup_query_line(line)

    @staticmethod
    def __is_alignment(text: str) -> bool:
        """
        Checks if the given text block is an alignment.
        :param text: Text part
        :return: True if the text is an alignment
        """
        if not re.search('^Length=', text, re.MULTILINE):
            return False
        try:
            AlignmentExtraction.__get_alignment_end_line_number(text)
        except ValueError:
            return False
        return True

    @staticmethod
    def __clean_alignment(alignment: str) -> str:
        """
        Cleans the given alignment. Trailing information is removed.
        :param alignment: Input alignment
        :return: Cleaned alignment
        """
        return '\n'.join(alignment.split('\n')[0:AlignmentExtraction.__get_alignment_end_line_number(alignment) + 1])

    @staticmethod
    def __get_alignment_end_line_number(alignment: str) -> int:
        """
        Returns the line number of the last line of the alignment.
        :param alignment: Alignment in BLAST output format 0, if the provided input is no alignment an error is raised.
        :return: Line number
        """
        match = re.search(r'(Sbjct {2}\d+ +[\w-]+ {2}\d+\n\n\n)', alignment)
        if match:
            last_line = match.group(1)
            return alignment.split('\n').index(last_line.strip())
        else:
            raise ValueError('Cannot determine the last line of the alignment')

    @staticmethod
    def __cleanup_query_line(line: str) -> str:
        """
        Cleans up the given query line.
        :param line: Line containing the query
        :return: Query
        """
        seq_id = line.replace('Query= ', '').split(' ')[0]

        # Workaround when commas are present in sequence id
        if ',' in seq_id:
            seq_id = seq_id.split(',')[0] + ','

        # Return key
        return seq_id.strip()[0:AlignmentExtraction.MAX_QUERY_LENGTH]
